#!/usr/bin/env python3

# TODO: Get game DNA
#          Use a for iterator to make a single string.  Each unit's DNA is 3 chars long.
# TODO: Genetic algorithm:
#       Get game DNA above from 'good' games
#       Split in 2 parts (a, b)
#       Combine to form 4 new dna strands (a1+a2), (a1+b2), (a2+b1), (b1+b2), select and place units based on dna
#           How to deconflict hex locations?
#       Play game as normal, logging results
#
# TODO: Format for 80 columns

import mysql.connector
import random
import sys
import uuid
from ogre.commandPost import *
from ogre.map import *
from ogre.ogre import *
from ogre.unit import *
from ogre.unitType import *


# Flags
DEBUG = False
INTERACTIVE = False

# Constants
ARMOR_POINTS = 20
INFANTRY_POINTS = 12
NUMBER_OF_TRAINING_GAMES = 100
HOMOGENEOUS_PROBABILITY = .25	# Default .25
HETEROGENEOUS_PROBABILITY = .75	# Default .75
MUTATION_PROBABILITY = .05	# Default .05

# Variables
#
# Format = {'UnitType.Type': (MP, A, R, D, C, #, [MP2])}
armorUnits = {'GEV': (4, 2, 2, 2, 1, 10, 3), 'HVY': (3, 4, 2, 3, 1, 10), 
              'MSL': (2, 3, 4, 2, 1, 8), 'HWZ': (0, 6, 8, 1, 2, 8)}

infantryUnits = {'INF1': (2, 1, 1, 1, 1, 8), 'INF2': (2, 2, 1, 2, 2, 22), 
                 'INF3': (2, 3, 1, 3, 3, 8)}

combinedUnits = {'GEV': (4, 2, 2, 2, 1, 10, 3), 'HVY': (3, 4, 2, 3, 1, 10),
                 'MSL': (2, 3, 4, 2, 1, 8), 'HWZ': (0, 6, 8, 1, 2, 8),
                 'INF1': (2, 1, 1, 1, 1, 8), 'INF2': (2, 2, 1, 2, 2, 22),
                 'INF3': (2, 3, 1, 3, 3, 8)}
 
# where:
#    1. MP = Movement points
#    2.  A = Attack value
#    3.  R = Range
#    4.  D = Defense value
#    5.  C = Cost
#    6.  # = Number of counters available 
#   [7.] MP2 = Movement points, 2nd phase

# Run the simulation 'n' times, which can be specified on the command line
# with a -n [x] switch
if len(sys.argv) == 3:
    if sys.argv[1] == '-n':
        n = int(sys.argv[2])
        if n > 0:
            iterations = n
        else:
            iterations = 1
    else:
        iterations = 100
else:
    iterations = 1  # Fail safe

typesOfVictory = {1: 'Complete OGRE victory', 
                  2: 'OGRE victory', 
                  3: 'Marginal OGRE victory', 
                  5: 'Marginal defense victory', 
                  4: 'Defense victory', 
                  6: 'Complete defense victory'} 

if __name__ == '__main__':
    # Create the classic OGRE  map (an 'even-q vertical offset' layout
    numberOfRows = 22
    numberOfColumns = 15

    myMap = Map(numberOfRows, numberOfColumns)

    # Add craters
    myMap.changeHexType('0107', Terrain.CRATER)
    myMap.changeHexType('0209', Terrain.CRATER)
    myMap.changeHexType('0303', Terrain.CRATER)
    myMap.changeHexType('0312', Terrain.CRATER)
    myMap.changeHexType('0505', Terrain.CRATER)
    myMap.changeHexType('0608', Terrain.CRATER)
    myMap.changeHexType('0611', Terrain.CRATER)
    myMap.changeHexType('0711', Terrain.CRATER)
    myMap.changeHexType('0907', Terrain.CRATER)
    myMap.changeHexType('0913', Terrain.CRATER)
    myMap.changeHexType('1004', Terrain.CRATER)
    myMap.changeHexType('1303', Terrain.CRATER)
    myMap.changeHexType('1309', Terrain.CRATER)
    myMap.changeHexType('1403', Terrain.CRATER)
    myMap.changeHexType('1406', Terrain.CRATER)
    myMap.changeHexType('1413', Terrain.CRATER)
    myMap.changeHexType('1507', Terrain.CRATER)

    # Add ridges
    #
    # Column 1
    myMap.changeHexLine('0102', Direction.SOUTHEAST, Terrain.RIDGE)
    myMap.changeHexLine('0103', Direction.NORTHEAST, Terrain.RIDGE)

    # Column 2
    myMap.changeHexLine('0203', Direction.SOUTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('0203', Direction.NORTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('0207', Direction.SOUTHEAST, Terrain.RIDGE)
    myMap.changeHexLine('0210', Direction.SOUTHEAST, Terrain.RIDGE)
    myMap.changeHexLine('0211', Direction.SOUTHEAST, Terrain.RIDGE)
    myMap.changeHexLine('0212', Direction.NORTHEAST, Terrain.RIDGE)

    # Column 3
    myMap.changeHexLine('0304', Direction.SOUTHEAST, Terrain.RIDGE)
    myMap.changeHexLine('0306', Direction.SOUTH, Terrain.RIDGE)
    myMap.changeHexLine('0307', Direction.NORTH, Terrain.RIDGE)
    myMap.changeHexLine('0307', Direction.NORTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('0308', Direction.SOUTHEAST, Terrain.RIDGE)
    myMap.changeHexLine('0309', Direction.SOUTHEAST, Terrain.RIDGE)
    myMap.changeHexLine('0310', Direction.NORTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('0310', Direction.SOUTH, Terrain.RIDGE)
    myMap.changeHexLine('0311', Direction.NORTH, Terrain.RIDGE)
    myMap.changeHexLine('0311', Direction.NORTHEAST, Terrain.RIDGE)
    myMap.changeHexLine('0311', Direction.SOUTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('0311', Direction.NORTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('0315', Direction.SOUTHEAST, Terrain.RIDGE)
    myMap.changeHexLine('0315', Direction.SOUTH, Terrain.RIDGE)

    # Column 4
    myMap.changeHexLine('0404', Direction.SOUTHEAST, Terrain.RIDGE)
    myMap.changeHexLine('0404', Direction.SOUTH, Terrain.RIDGE)
    myMap.changeHexLine('0405', Direction.NORTH, Terrain.RIDGE)
    myMap.changeHexLine('0405', Direction.NORTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('0408', Direction.SOUTHEAST, Terrain.RIDGE)
    myMap.changeHexLine('0409', Direction.NORTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('0410', Direction.NORTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('0411', Direction.SOUTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('0416', Direction.SOUTHWEST, Terrain.RIDGE)

    # Column 5
    myMap.changeHexLine('0502', Direction.NORTHEAST, Terrain.RIDGE)
    myMap.changeHexLine('0504', Direction.NORTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('0508', Direction.NORTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('0513', Direction.SOUTHEAST, Terrain.RIDGE)
    myMap.changeHexLine('0514', Direction.NORTHEAST, Terrain.RIDGE)

    # Column 6
    myMap.changeHexLine('0602', Direction.SOUTH, Terrain.RIDGE)
    myMap.changeHexLine('0602', Direction.SOUTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('0603', Direction.NORTH, Terrain.RIDGE)
    myMap.changeHexLine('0603', Direction.NORTHEAST, Terrain.RIDGE)
    myMap.changeHexLine('0607', Direction.NORTHEAST, Terrain.RIDGE)
    myMap.changeHexLine('0607', Direction.SOUTHEAST, Terrain.RIDGE)
    myMap.changeHexLine('0614', Direction.NORTH, Terrain.RIDGE)
    myMap.changeHexLine('0614', Direction.SOUTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('0614', Direction.NORTHWEST, Terrain.RIDGE)

    # Column 7
    myMap.changeHexLine('0702', Direction.SOUTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('0706', Direction.SOUTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('0707', Direction.SOUTH, Terrain.RIDGE)
    myMap.changeHexLine('0707', Direction.NORTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('0708', Direction.NORTH, Terrain.RIDGE)
    myMap.changeHexLine('0713', Direction.NORTHEAST, Terrain.RIDGE)
    myMap.changeHexLine('0713', Direction.SOUTHEAST, Terrain.RIDGE)
    myMap.changeHexLine('0715', Direction.SOUTHEAST, Terrain.RIDGE)

    # Column 8
    myMap.changeHexLine('0801', Direction.SOUTHEAST, Terrain.RIDGE)
    myMap.changeHexLine('0808', Direction.SOUTHEAST, Terrain.RIDGE)
    myMap.changeHexLine('0812', Direction.NORTHEAST, Terrain.RIDGE)
    myMap.changeHexLine('0812', Direction.SOUTHEAST, Terrain.RIDGE)
    myMap.changeHexLine('0813', Direction.SOUTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('0814', Direction.NORTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('0815', Direction.SOUTH, Terrain.RIDGE)
    myMap.changeHexLine('0816', Direction.NORTH, Terrain.RIDGE)
    myMap.changeHexLine('0816', Direction.NORTHEAST, Terrain.RIDGE)
    myMap.changeHexLine('0816', Direction.NORTHWEST, Terrain.RIDGE)

    # Column 9
    myMap.changeHexLine('0901', Direction.NORTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('0903', Direction.NORTHEAST, Terrain.RIDGE)
    myMap.changeHexLine('0903', Direction.SOUTH, Terrain.RIDGE)
    myMap.changeHexLine('0904', Direction.NORTH, Terrain.RIDGE)
    myMap.changeHexLine('0904', Direction.SOUTHEAST, Terrain.RIDGE)
    myMap.changeHexLine('0904', Direction.SOUTH, Terrain.RIDGE)
    myMap.changeHexLine('0906', Direction.SOUTHEAST, Terrain.RIDGE)
    myMap.changeHexLine('0908', Direction.NORTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('0910', Direction.NORTHEAST, Terrain.RIDGE)
    myMap.changeHexLine('0911', Direction.SOUTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('0912', Direction.NORTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('0915', Direction.SOUTH, Terrain.RIDGE)
    myMap.changeHexLine('0915', Direction.SOUTHWEST, Terrain.RIDGE)

    # Column 10
    myMap.changeHexLine('1003', Direction.SOUTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('1005', Direction.NORTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('1007', Direction.NORTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('1008', Direction.NORTHEAST, Terrain.RIDGE)
    myMap.changeHexLine('1010', Direction.SOUTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('1012', Direction.NORTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('1012', Direction.SOUTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('1012', Direction.SOUTH, Terrain.RIDGE)
    myMap.changeHexLine('1015', Direction.SOUTHEAST, Terrain.RIDGE)

    # Column 11
    myMap.changeHexLine('1106', Direction.SOUTHEAST, Terrain.RIDGE)
    myMap.changeHexLine('1107', Direction.NORTHEAST, Terrain.RIDGE)
    myMap.changeHexLine('1107', Direction.SOUTHEAST, Terrain.RIDGE)
    myMap.changeHexLine('1107', Direction.SOUTH, Terrain.RIDGE)
    myMap.changeHexLine('1107', Direction.SOUTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('1111', Direction.SOUTHEAST, Terrain.RIDGE)
    myMap.changeHexLine('1111', Direction.SOUTH, Terrain.RIDGE)
    myMap.changeHexLine('1111', Direction.SOUTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('1112', Direction.NORTH, Terrain.RIDGE)
    myMap.changeHexLine('1112', Direction.NORTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('1115', Direction.NORTHWEST, Terrain.RIDGE)

    # Column 12
    myMap.changeHexLine('1204', Direction.SOUTH, Terrain.RIDGE)
    myMap.changeHexLine('1205', Direction.NORTH, Terrain.RIDGE)
    myMap.changeHexLine('1205', Direction.NORTHEAST, Terrain.RIDGE)
    myMap.changeHexLine('1206', Direction.SOUTH, Terrain.RIDGE)
    myMap.changeHexLine('1207', Direction.NORTH, Terrain.RIDGE)
    myMap.changeHexLine('1207', Direction.SOUTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('1207', Direction.NORTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('1208', Direction.NORTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('1212', Direction.NORTHWEST, Terrain.RIDGE)

    # Column 13
    myMap.changeHexLine('1304', Direction.SOUTHWEST, Terrain.RIDGE)
    myMap.changeHexLine('1315', Direction.SOUTHEAST, Terrain.RIDGE)
    myMap.changeHexLine('1315', Direction.SOUTH, Terrain.RIDGE)
    myMap.changeHexLine('1316', Direction.NORTH, Terrain.RIDGE)

    # Column 14
    myMap.changeHexLine('1408', Direction.SOUTH, Terrain.RIDGE)
    myMap.changeHexLine('1409', Direction.NORTH, Terrain.RIDGE)
    myMap.changeHexLine('1415', Direction.SOUTH, Terrain.RIDGE)
    myMap.changeHexLine('1416', Direction.NORTH, Terrain.RIDGE)
    myMap.changeHexLine('1416', Direction.NORTHWEST, Terrain.RIDGE)

    # Column 15
    # None

    # Plan 'n' games
    while iterations > 0:
        # Generate a unique 'game id' for tracking statistics
        gameID = uuid.uuid1()

        # Create some lists to keep track of units
        defenderUnits = []
        disabledDefenderUnits = []
        recoverableDefenderUnits = []
        destroyedDefenderUnits = []
        randomHexesUsed = []

        # Remove any left over units on the map from the previous game (if any)
        myMap.clearUnits()

        # See how many training games exist, then determine how best
        # to select the defending units for the next game.
        dbConnection = mysql.connector.connect(user='ogre',
                                               password='ogrepw',
                                               host='localhost',
                                               database='ogre')
        query = ('SELECT COUNT(*) AS GamesPlayed FROM Games')
        cursor = dbConnection.cursor()
        cursor.execute(query)
        for (GamesPlayed) in cursor:
            numberOfGamesPlayed = GamesPlayed[0]

        if numberOfGamesPlayed >= NUMBER_OF_TRAINING_GAMES:
            # Use a genetic algorithm to choose a mix of armor and infantry units
            # to randomly place on the map, according to the rules regarding
            # point totals in the 'defender zone' and the 'obstructed zone'.
            # The probability of mutation is a constant so you can easily change it.
            topGames = []
            gameADNA = []
            gameBDNA = []

            # This query returns the 'Game.id' of the top 10 most favorable games
            # for the defender
            query = "SELECT id FROM Games ORDER BY victoryTypeID DESC, " + \
                    "cpDestroyed DESC, remainingDefensePoints DESC, " + \
                    "turns ASC LIMIT 10"
            cursor.execute(query)
            for (id) in cursor:
                topGames.append(id[0])
            # Now pick two of the top 10 games at random
            gameAID = random.choice(topGames)
            gameBID = random.choice(topGames)

            # Now get the 'DNA', which is a unit type gene plus a behavior gene
            # for each unit that participated in that game.

            # Game A
            query = "SELECT CONCAT(ut.gene, b.gene) as UnitGene FROM Units u " + \
                    "INNER JOIN UnitTypes ut ON u.unitTypeID = ut.id " + \
                    "INNER JOIN Behaviors b ON u.behaviorID = b.id " + \
                    "WHERE u.gameID = " + str(gameAID)
            cursor.execute(query)
            for (UnitGene) in cursor:
                gameADNA.append(UnitGene[0])

            # Game B
            query = "SELECT CONCAT(ut.gene, b.gene) as UnitGene FROM Units u " + \
                    "INNER JOIN UnitTypes ut ON u.unitTypeID = ut.id " + \
                    "INNER JOIN Behaviors b ON u.behaviorID = b.id " + \
                    "WHERE u.gameID = " + str(gameBID)
            cursor.execute(query)
            for (UnitGene) in cursor:
                gameBDNA.append(UnitGene[0])

            # print('Game A DNA', gameADNA)  # DEBUG INFO
            # print('Game B DNA', gameBDNA)  # DEBUG INFO

            # Create four substrands of DNA
            strandA1 = ''
            for i in range(0, len(gameADNA)//2):
                strandA1 += gameADNA[i]

            strandA2 = ''
            for i in range(len(gameADNA)//2+1, len(gameADNA)):
                strandA2 += gameADNA[i]

            strandB1 = ''
            for i in range(0, len(gameBDNA)//2):
                strandB1 += gameBDNA[i]

            strandB2 = ''
            for i in range(len(gameBDNA)//2+1, len(gameBDNA)):
                strandB2 += gameBDNA[i]

            # There are four combinations of new DNA strands we can construct:
            # TODO: Implement probability of mutation
            newStrand1 = strandA1 + strandA2
            newStrand2 = strandA1 + strandB2
            newStrand3 = strandA2 + strandB1
            newStrand4 = strandB1 + strandB2

            # print(strandA1)  # DEBUG INFO
            # print(strandA2)  # DEBUG INFO
            # print(strandB1)  # DEBUG INFO
            # print(strandB2)  # DEBUG INFO

            # Randomly pick a new strand to use for the next game
            newStrands = [newStrand1, newStrand2, newStrand3, newStrand4]
            newStrand = random.choice(newStrands)
            # print('newStrand =', newStrand)  # DEBUG INFO
            # Keep track of the current point expendatures, because there is
            # no guarantee that the new strand of DNA is legal in terms of
            # the scenario (20 armor and 12 infantry)
            i = 0
            armorPoints = 0
            infantryPoints = 0 

            while i < len(newStrand)-3:
                currentUnitDNA = newStrand[i:i+3]
                unitType = currentUnitDNA[0:2]
                unitBehavior = currentUnitDNA[2:3]
                # print('unitType, behavior =', unitType, unitBehavior)  # DEBUG INFO
                # Translate gene to unit
                if unitType == 'I1':
                    randomUnit = 'INF1'
                elif unitType == 'I2':
                    randomUnit = 'INF2'
                elif unitType == 'I3':
                    randomUnit = 'INF3'
                elif unitType == 'GV':
                    randomUnit = 'GEV'
                elif unitType == 'HV':
                    randomUnit = 'HVY'
                elif unitType == 'HZ':
                    randomUnit = 'HWZ'
                elif unitType == 'MT':
                    randomUnit = 'MSL'
                
                i += 1  # Unit name suffix
                points = combinedUnits[randomUnit][4]
                # Local unit attribute variables
                unitName = randomUnit.lower()+str(i)

                # Skip the unit if we already have the maximum point total for that type of unit
                if (randomUnit == 'INF1' \
                    or randomUnit == 'INF2' \
                    or randomUnit == 'INF3') and infantryPoints >= INFANTRY_POINTS:
                    pass
                elif (randomUnit == 'GEV' \
                      or randomUnit == 'HVY' \
                      or randomUnit == 'HWZ' \
                      or randomUnit == 'MSL') and armorPoints >= ARMOR_POINTS:
                    pass
                else:
                    unitType = 'UnitType.'+randomUnit.upper()
                    mp = combinedUnits[randomUnit][0]
                    # Make all locaionts '0000' when units are  created, 
                    # then randomly generate a location and update unit objects 
                    # and the map at the same time.  (Checking that the random hex is open
                    # no unit present and not a crater.)
                    hexLocation = '0000'
                    attack = combinedUnits[randomUnit][1]
                    range_ = combinedUnits[randomUnit][2]
                    defense = combinedUnits[randomUnit][3]
                    # Create the unit
                    exec(unitName + "= Unit('" + unitName +"', " + unitType + ", " + str(points) + \
                         ", '" + hexLocation + "', movementPoints=" + str(mp) + ", attackStrength=" + str(attack) + \
                         ", range_=" + str(range_) + ", defenseStrength=" + str(defense) + ")")
                    # Add the unit to the 'defenderUnit' list
                    exec("defenderUnits.append('"+unitName+"')")
                    if unitType == 'UnitType.INF1' \
                       or unitType == 'UnitType.INF2' \
                       or unitType == 'UnitType.INF3':
                        infantryPoints += points
                    else:
                        armorPoints += points
                i +=3

            # print('Current armor points:', str(armorPoints))  # DEBUG INFO
            # print('Current infantry points:', str(infantryPoints))  # DEBUG INFO
            # print('Current combined points:', str(infantryPoints + armorPoints))  # DEBUG INFO

            # Round out armor counters
            while armorPoints < ARMOR_POINTS:
                # Get a random armor unit type
                randomUnit = random.choice(list(armorUnits.keys()))
                i += 1  # Unit name suffix
                points = armorUnits[randomUnit][4]
                # Local unit attribute variables
                unitName = randomUnit.lower()+str(i)
                unitType = 'UnitType.'+randomUnit.upper()
                mp = armorUnits[randomUnit][0]
                # Make all locaionts '0000' when units are  created, 
                # then randomly generate a location and update unit objects 
                # and the map at the same time.  (Checking that the random hex is op
                # no unit present and not a crater.)
                hexLocation = '0000'
                attack = armorUnits[randomUnit][1]
                range_ = armorUnits[randomUnit][2]
                defense = armorUnits[randomUnit][3]
                # Create the unit
                exec(unitName + "= Unit('" + unitName +"', " + unitType + ", " + str(points) + \
                     ", '" + hexLocation + "', movementPoints=" + str(mp) + ", attackStrength=" + str(attack) + \
                     ", range_=" + str(range_) + ", defenseStrength=" + str(defense) + ")")
                # Add the unit to the 'defenderUnit' list
                exec("defenderUnits.append('"+unitName+"')")
                armorPoints += points
            # Round out infantry counters
            while infantryPoints < INFANTRY_POINTS:
                i += 1  # Unit name suffix
                # Get a random infantry unit type
                randomUnit = random.choice(list(infantryUnits.keys()))
                points = infantryUnits[randomUnit][4]
                # Ensure we don't take more infantry than allowed by the rules
                while infantryPoints + points > INFANTRY_POINTS:
                    randomUnit = random.choice(list(infantryUnits.keys()))
                    points = infantryUnits[randomUnit][4]
                # Local unit attribute variables
                unitName = randomUnit.lower()+str(i)
                unitType = 'UnitType.'+randomUnit.upper()
                mp = infantryUnits[randomUnit][0]
                # Make all locaionts '0000' when units are  created, 
                # then randomly generate a location and update unit objects 
                # and the map at the same time.  (Checking that the random hex is open
                # no unit present and not a crater.)
                hexLocation = '0000'
                attack = infantryUnits[randomUnit][1]
                range_ = infantryUnits[randomUnit][2]
                defense = infantryUnits[randomUnit][3]
                # Create the unit
                exec(unitName + "= Unit('" + unitName +"', " + unitType + ", " + str(points) + \
                     ", '" + hexLocation + "', movementPoints=" + str(mp) + ", attackStrength=" + str(attack) + \
                     ", range_=" + str(range_) + ", defenseStrength=" + str(defense) + ")")
                # Add the unit to the 'defenderUnit' list
                exec("defenderUnits.append('"+unitName+"')")
                infantryPoints += points

            # print('Current armor points:', str(armorPoints))  # DEBUG INFO
            # print('Current infantry points:', str(infantryPoints))  # DEBUG INFO
            # print('Current combined points:', str(infantryPoints + armorPoints))  # DEBUG INFO

        else:
            # Randomly choose units if there are not enough training games in
            # the database.  The probabilities for homogeneous and heterogeneous
            # units are constants so you can easily change them. 
            #
            # Armor
            unitTypeProbability = round(random.random(), 2)
            if unitTypeProbability <= HETEROGENEOUS_PROBABILITY:
                # Heterogeneous armor
                armorPoints = 0
                i = 0
                while armorPoints < ARMOR_POINTS:
                    i += 1  # Unit name suffix
                    # Get a random armor unit type
                    randomUnit = random.choice(list(armorUnits.keys()))
                    points = armorUnits[randomUnit][4]
                    # Ensure we don't take more armor than allowed by the rules
                    while armorPoints + points > ARMOR_POINTS:
                        randomUnit = random.choice(list(armorUnits.keys()))
                        points = armorUnits[randomUnit][4]
                    # Local unit attribute variables
                    unitName = randomUnit.lower()+str(i)
                    unitType = 'UnitType.'+randomUnit.upper()
                    mp = armorUnits[randomUnit][0]
                    # Make all locaionts '0000' when units are  created, 
                    # then randomly generate a location and update unit objects 
                    # and the map at the same time.  (Checking that the random hex is open
                    # no unit present and not a crater.)
                    hexLocation = '0000'
                    attack = armorUnits[randomUnit][1]
                    range_ = armorUnits[randomUnit][2]
                    defense = armorUnits[randomUnit][3]
                    # Create the unit
                    exec(unitName + "= Unit('" + unitName +"', " + unitType + ", " + str(points) + \
                         ", '" + hexLocation + "', movementPoints=" + str(mp) + ", attackStrength=" + str(attack) + \
                         ", range_=" + str(range_) + ", defenseStrength=" + str(defense) + ")")
                    # Add the unit to the 'defenderUnit' list
                    exec("defenderUnits.append('"+unitName+"')")
                    armorPoints += points
            else:
                # Homogeneous armor
                armorPoints = 0
                i = 0
                # Get a random armor unit type
                randomUnit = random.choice(list(armorUnits.keys()))
                while armorPoints < ARMOR_POINTS:
                    i += 1  # Unit name suffix
                    points = armorUnits[randomUnit][4]
                    # Local unit attribute variables
                    unitName = randomUnit.lower()+str(i)
                    unitType = 'UnitType.'+randomUnit.upper()
                    mp = armorUnits[randomUnit][0]
                    # Make all locaionts '0000' when units are  created, 
                    # then randomly generate a location and update unit objects 
                    # and the map at the same time.  (Checking that the random hex is open
                    # no unit present and not a crater.)
                    hexLocation = '0000'
                    attack = armorUnits[randomUnit][1]
                    range_ = armorUnits[randomUnit][2]
                    defense = armorUnits[randomUnit][3]
                    # Create the unit
                    exec(unitName + "= Unit('" + unitName +"', " + unitType + ", " + str(points) + \
                         ", '" + hexLocation + "', movementPoints=" + str(mp) + ", attackStrength=" + str(attack) + \
                         ", range_=" + str(range_) + ", defenseStrength=" + str(defense) + ")")
                    # Add the unit to the 'defenderUnit' list
                    exec("defenderUnits.append('"+unitName+"')")
                    armorPoints += points

            # Infantry
            unitTypeProbability = round(random.random(), 2)
            if unitTypeProbability <= HETEROGENEOUS_PROBABILITY:
                # Heterogeneous infantry
                infantryPoints = 0
                i = 0
                while infantryPoints < INFANTRY_POINTS:
                    i += 1  # Unit name suffix
                    # Get a random infantry unit type
                    randomUnit = random.choice(list(infantryUnits.keys()))
                    points = infantryUnits[randomUnit][4]
                    # Ensure we don't take more infantry than allowed by the rules
                    while infantryPoints + points > INFANTRY_POINTS:
                        randomUnit = random.choice(list(infantryUnits.keys()))
                        points = infantryUnits[randomUnit][4]
                    # Local unit attribute variables
                    unitName = randomUnit.lower()+str(i)
                    unitType = 'UnitType.'+randomUnit.upper()
                    mp = infantryUnits[randomUnit][0]
                    # Make all locaionts '0000' when units are  created, 
                    # then randomly generate a location and update unit objects 
                    # and the map at the same time.  (Checking that the random hex is open
                    # no unit present and not a crater.)
                    hexLocation = '0000'
                    attack = infantryUnits[randomUnit][1]
                    range_ = infantryUnits[randomUnit][2]
                    defense = infantryUnits[randomUnit][3]
                    # Create the unit
                    exec(unitName + "= Unit('" + unitName +"', " + unitType + ", " + str(points) + \
                         ", '" + hexLocation + "', movementPoints=" + str(mp) + ", attackStrength=" + str(attack) + \
                         ", range_=" + str(range_) + ", defenseStrength=" + str(defense) + ")")
                    # Add the unit to the 'defenderUnit' list
                    exec("defenderUnits.append('"+unitName+"')")
                    infantryPoints += points
            else:
                # Homogeneous infantry
                infantryPoints = 0
                i = 0
                # Get a random infantry unit type
                randomUnit = random.choice(list(infantryUnits.keys()))
                while infantryPoints < INFANTRY_POINTS:
                    i += 1  # Unit name suffix
                    points = infantryUnits[randomUnit][4]
                    # Local unit attribute variables
                    unitName = randomUnit.lower()+str(i)
                    unitType = 'UnitType.'+randomUnit.upper()
                    mp = infantryUnits[randomUnit][0]
                    # Make all locaionts '0000' when units are  created, 
                    # then randomly generate a location and update unit objects 
                    # and the map at the same time.  (Checking that the random hex is open
                    # no unit present and not a crater.)
                    hexLocation = '0000'
                    attack = infantryUnits[randomUnit][1]
                    range_ = infantryUnits[randomUnit][2]
                    defense = infantryUnits[randomUnit][3]
                    # Create the unit
                    exec(unitName + "= Unit('" + unitName +"', " + unitType + ", " + str(points) + \
                         ", '" + hexLocation + "', movementPoints=" + str(mp) + ", attackStrength=" + str(attack) + \
                         ", range_=" + str(range_) + ", defenseStrength=" + str(defense) + ")")
                    # Add the unit to the 'defenderUnit' list
                    exec("defenderUnits.append('"+unitName+"')")
                    infantryPoints += points

        # Iterate through the 'defenderUnit' list according to the rules
        unitsToDeploy = defenderUnits[:]  # Deep copy
        random.shuffle(unitsToDeploy)

        # Place 12 units of strength in 'obstructed' zone (0101, 1501, 0116, 1516)
        deployedPoints = 0
        while deployedPoints <= 12:
            # Get a random unit
            unit = unitsToDeploy.pop()
            # Get a random hex that is open
            # (open means no unit present and not a crater)
            randomHex = myMap.getRandomHex(14, 15)
            while randomHex in randomHexesUsed:
                randomHex = myMap.getRandomHex(14, 15)
            randomHexesUsed.append(randomHex)
            # Set the unit's location to the random hex
            eval(unit +".setLocation('" + randomHex + "')")
            # Add the unit to the map
            q, r = myMap.getQRFromHexID(randomHex)
            myMap.hexagons[r][q].addUnit(eval(unit))
            # Add the unit's point cost to the total points deployed
            points = eval(unit +".points")
            deployedPoints += points
            # Log the unit
            behaviorTypeID = 1  # Brave (The only implemented behavior at this time)
            unitTypeID = eval(unit + '.getDBID(' + unit + '.unitName)')
            query = 'INSERT INTO Units (unitTypeID, behaviorID, startingHex) values (' + \
                    unitTypeID + ', ' + str(behaviorTypeID) + ', + "' + randomHex + '")'
            cursor.execute(query)
            dbConnection.commit()
            if DEBUG: print('Placed', eval(unit + ".unitType"), 'at', randomHex)

        # Place remaining units of strength in 'defender' zone (0101, 1501, 0107, 1507) 
        while unitsToDeploy:
            # Get a random unit
            unit = unitsToDeploy.pop()
            # Get a random hex that is open
            # (open means no unit present and not a crater)
            randomHex = myMap.getRandomHex(14, 7)
            while randomHex in randomHexesUsed:
                randomHex = myMap.getRandomHex(14, 7)
            randomHexesUsed.append(randomHex)
            # Set the unit's location to the random hex
            eval(unit +".setLocation('" + randomHex + "')")
            # Add the unit to the map
            q, r = myMap.getQRFromHexID(randomHex)
            myMap.hexagons[r][q].addUnit(eval(unit))
            # Add the unit's point cost to the total points deployed
            points = eval(unit +".points")
            deployedPoints += points
            # Log the unit
            behaviorTypeID = 1  # Brave (The only implemented behavior at this time)
            unitTypeID = eval(unit + '.getDBID(' + unit + '.unitName)')
            query = 'INSERT INTO Units (unitTypeID, behaviorID, startingHex) values (' + \
                    unitTypeID + ', ' + str(behaviorTypeID) + ', + "' + randomHex + '")'
            cursor.execute(query)
            dbConnection.commit()
            if DEBUG: print('Placed', eval(unit + ".unitType"), 'at', randomHex)

        # A common strategy is to place the command post on the first row
        # of the map (e.g. '1401')  I will use that strategy, but randomly
        # pick a column in the first row.
        #
        # Command Post
        randomColumn = str(random.randint(1, myMap.q))
        if len(randomColumn) == 1:
            randomColumn = '0' + randomColumn
        randomHex = randomColumn + '01'
        if DEBUG: print('CP placed at', randomHex)
        cp = CommandPost(randomHex)			# E.g. "CommandPost('hexLocation')"
        cp.setLocation(randomHex)			# Store unit's current location
        r, q = myMap.getRQFromHexID(randomHex) 
        myMap.hexagons[r][q].addUnit(cp)		# Place unit on map
        defenderUnits.append(cp.unitName)		# Add unit to list of defender units

        # Create the OGRE
        mk3 = Ogre('MK3',  # name
                      45,  # tread (45)
                       2,  # missiles (2)
                       1,  # main battery (1)
                       4,  # secondary battery (4)
                       8)  # antipersonnel
        # Place the OGRE (same place each game)
        mk3.setLocation('1222')
        r, q = myMap.getRQFromHexID('1222')
        myMap.hexagons[r][q].addUnit(mk3)


        #############
        # Game loop #
        #############

        # 1. Check for victory (DONE) 
        endOfGame = False
        typeOfVictory = None
        turn = 1
        while not endOfGame:
            if DEBUG: print('\nTurn', turn)
            if DEBUG: print(myMap)

            # CP location is used by several functions in the game loop
            cpHexID = None
            if 'cp' in locals():
                cpHexID = cp.hexLocation

            # Check for the various game ending conditions:
            # If the OGRE is immobile, examine remaining weapon systems and distance from CP to determine end of game condition
            if mk3.tread <= 0:
                if 'cp' in locals():
                    q_cp, r_cp = myMap.getQRFromHexID(cpHexID)
                    cpCubeCoords = myMap.convertAxial2Cube(q_cp, r_cp)
                    q_o, r_o = myMap.getQRFromHexID(mk3.hexLocation)
                    ogreCubeCoords = myMap.convertAxial2Cube(q_o, r_o)
                    distance = myMap.getDistance(ogreCubeCoords, cpCubeCoords)
                else:
                    distance = float('inf')
                endOfGame = True
                if mk3.missiles > 0 and distance <= Missile.range:
                    endOfGame = False
                if mk3.mainBattery > 0 and distance <= MainBattery.range:
                    endOfGame = False
                if mk3.secondaryBattery > 0 and distance <= SecondaryBattery.range:
                    endOfGame = False
                if endOfGame and 'cp' in locals():
                    typeOfVictory = 4  # Defense victory
                else:
                    typeOfVictory = 3  # Marginal OGRE victory
            
            # Or if the OGRE has been destroyed        
            elif mk3.status == Status.DESTROYED:
                endOfGame = True
                points = 0
                for unit in defenderUnits:
                    points += eval(unit + '.points')
                for unit in disabledDefenderUnits:
                    points += eval(unit + '.points')
                for unit in recoverableDefenderUnits:
                    points += eval(unit + '.points')
                if points >= 30:
                    typeOfVictory = 6  # Complete defence victory
                else:
                    typeOfVictory = 4  # Defence victory

            # Or if the CP and all defending units have been destroyed, and the
            elif 'cp' not in locals() and \
                 (len(defenderUnits) == 0 and \
                  len(disabledDefenderUnits) == 0 and \
                  len(recoverableDefenderUnits) == 0):
                endOfGame = True
                # TECHNICAL DEBT: Currently the OGRE will not pursue armor, and always flees
                #                 making a complete victory impossible
                typeOfVictory = 1  # Complete OGRE victory

            # Or if the OGRE has destroyed the CP and has fled to the south of the map
            elif  ('cp' not in locals() and mk3.hexLocation[2:4] == '22'):
                endOfGame = True
                typeOfVictory = 2  # OGRE victory

            # 2. OGRE move  (DONE)
            mk3.move(myMap, cpHexID)
 
            # 3. OGRE fire  (DONE)
            mk3.fire(myMap, defenderUnits, disabledDefenderUnits, 
                     recoverableDefenderUnits, destroyedDefenderUnits)
            #    a. Remove destroyed units from the map
            for unit in destroyedDefenderUnits[:]:
                # Remove unit from map
                q, r = eval('myMap.getQRFromHexID(' + unit + '.hexLocation)')
                myMap.hexagons[r][q].unitPresent = None
                # Try and remove unit from tracking lists
                #
                # Defending units
                try:
                    defenderUnits.remove(unit)
                except ValueError:
                    # Catch error if we try to remove a unit that has already been removed
                    pass
                # Disabled units
                try:
                    disabledDefenderUnits.remove(unit)
                except ValueError:
                    # Catch error if we try to remove a unit that has already been removed
                    pass
                # Recoverable units
                try:
                    recoverableDefenderUnits.remove(unit)
                except ValueError:
                    # Catch error if we try to remove a unit that has already been removed
                    pass
                # Finally, remove unit from destroyed unit tracking list
                try:
                    destroyedDefenderUnits.remove(unit)
                except ValueError:
                    # Catch error if we try to remove a unit that has already been removed
                    pass
                exec('del ' + unit)
            #    b. Remove disabled units from the defender list
            for unit in disabledDefenderUnits:
                try:
                    defenderUnits.remove(unit)
                except ValueError:
                    pass

            # 4. Defender recovery  (DONE)
            #    a. Move recoverable units back to the defender units list
            for unit in recoverableDefenderUnits:
                defenderUnits.append(unit)
            #    b. Clear the recoverable units list
            recoverableDefenderUnits = []
            #    c. Move disabled defender units to the recoverable defender units list
            #       so that they may be recovered next turn
            for unit in disabledDefenderUnits:
                recoverableDefenderUnits.append(unit)
            #    d. Clear the disabled units list
            disabledDefenderUnits = []

            # 5. Defender move  (DONE)
            for unit in defenderUnits:
                try:
                    eval(unit + ".move(myMap, mk3.hexLocation, cpHexID)")
                except NameError:
                    # Don't try to move a unit that may have been removed from the defenderUnits list
                    pass

            # 6. Defender fire  (DONE)
            # Keep track of the cumulative offensive fire power (OFP) targeted at each
            # system of the OGRE
            ogreMissileOFP = 0
            ogreMainOFP = 0
            ogreSecondaryOFP = 0
            target = None
            for unit in defenderUnits:
                if not mk3.isDestroyed():
                    # Check if unit's weapon system is in range of the OGRE
                    try:
                        q_u, r_u = eval('myMap.getQRFromHexID(' + unit + '.hexLocation)')
                        unitCubeCoords = myMap.convertAxial2Cube(q_u, r_u)
                        q_o, r_o = myMap.getQRFromHexID(mk3.hexLocation)
                        ogreCubeCoords = myMap.convertAxial2Cube(q_o, r_o)
                        distance = myMap.getDistance(unitCubeCoords, ogreCubeCoords)
                    except NameError:
                        distance = float('inf')  # invariant
                    # If in range of an OGRE that is not yet destroyed, 
                    # select target based on unit's behavior and non-destroyed OGRE systems
                    try:
                        if distance <= eval(unit + '.range_') and not mk3.isDestroyed():
                    
                            if DEBUG: eval("print(" + unit + ".unitName, 'at', " + unit + ".hexLocation, 'looking for a target...')")
                            if eval(unit + '.behavior') == Behavior.COWARDLY:
                                NotImplemented
                            elif eval(unit + '.behavior') == Behavior.DISCIPLINED:
                                NotImplemented
                            elif eval(unit + '.behavior') == Behavior.BRAVE and target is None:
                                # Probabalistically select an OGRE system to target
                                probability = round(random.random(), 2)
                                # print('Brave probability =', probability)  # DEBUG INFO
                                if probability <= .5:
                                    probability = round(random.random(), 2)
                                    if probability <= .5:
                                        target = Unit.selectTarget(mk3, 'missiles')
                                    else:
                                        target = Unit.selectTarget(mk3, 'mainBattery')
                                elif probability > .5 and probability <= .7:
                                    target = Unit.selectTarget(mk3, 'secondaryBattery')
                                else:
                                    target = Unit.selectTarget(mk3, 'tread')                
                            else:
                                pass

                            if target is not None:
                                # i. Assign current unit's attack strength to OGRE system, unless that system is
                                #    already an automatic 'X' (> 4:1), otherwise,
                                #    assign the current unit's attack strength to the next highest priority OGRE
                                #    system
                                if target == 'missiles' and ogreMissileOFP // Missile.defense < 4 and mk3.missiles > 0:
                                    ogreMissileOFP += eval(unit + '.attackStrength')
                                    if DEBUG: print('   +{} fire power assigned against OGRE missle'.format(eval(unit + '.attackStrength')))
                                else:
                                    target = Unit.selectTarget(mk3, 'mainBattery')
                                if target == 'mainBattery' and ogreMainOFP // MainBattery.defense < 4 and mk3.mainBattery > 0:
                                    ogreMainOFP += eval(unit + '.attackStrength')
                                    if DEBUG: print('   +{} fire power assigned against OGRE main battery'.format(eval(unit + '.attackStrength')))
                                else:
                                    target = Unit.selectTarget(mk3, 'secondaryBattery')
                                if target == 'secondaryBattery' and ogreSecondaryOFP // SecondaryBattery.defense < 4 and mk3.secondaryBattery > 0:
                                    ogreSecondaryOFP += eval(unit + '.attackStrength')
                                    if DEBUG: print('   +{} fire power assigned against OGRE secondary battery'.format(eval(unit + '.attackStrength')))
                                else:
                                    target == 'tread'
                                if target == 'tread' and mk3.tread > 0:
                                    if DEBUG: print('   Attacking OGRE tread with {} attack strength at 1:1'.format(eval(unit + '.attackStrength')))
                                    # Immediately resolve OGRE tread attack at 1-1
                                    outcome = CRT.crossReference(1, 1)
                                    if DEBUG: print('   CRT outcome:', outcome)
                                    if outcome == 'X':
                                        mk3.removeTread(eval(unit + '.attackStrength'))
                                        if DEBUG: print('      HIT!  Removing', eval(unit + '.attackStrength'), 'tread!')
                        else:
                            # print('OGRE out of range!')  # DEBUG INFO
                            pass
                    except NameError:
                        pass

            # iv: Resolve combat
            if ogreMissileOFP > 0:
                outcome = CRT.crossReference(ogreMissileOFP, Missile.defense)
                if DEBUG: print('Resolving attack on OGRE missiles\n   Outcome:', outcome)
                if outcome == 'X':
                    mk3.missiles -= 1
            if ogreMainOFP > 0:
                outcome = CRT.crossReference(ogreMainOFP, MainBattery.defense)
                if DEBUG: print('Resolving attack on OGRE main battery\n   Outcome:', outcome)
                if outcome == 'X':
                    mk3.mainBattery -= 1
            if ogreSecondaryOFP > 0:
                outcome = CRT.crossReference(ogreSecondaryOFP, SecondaryBattery.defense)
                if DEBUG: print('Resolving attack on OGRE secondary battery\n   Outcome:', outcome)
                if outcome == 'X':
                    mk3.secondaryBattery -= 1

            mk3.isDestroyed()

            # 7. TODO: GEV 2nd move

            turn += 1

            if INTERACTIVE:
                # Interactive mode
                # "Pause" until the user presses the space bar...
                go = input('Press the <ENTER> key to continue...')

            #################
            # END GAME LOOP #
            #################

        # Log outcome
        if 'cp' in locals():
            cpDestroyed = 'false'
        else:
            cpDestroyed = 'true'

        # Be certain of the OGRE's status
        if mk3.isDestroyed():
            ogreDestroyed = 'true'
        else:
            ogreDestroyed = 'false'

        remainingDefensePoints = 0
        for unit in defenderUnits:
            try:
                remainingDefensePoints += eval(unit + '.points')
            except NameError:
               pass
        for unit in disabledDefenderUnits:
            try:
                remainingDefensePoints += eval(unit + '.points')
            except NameError:
               pass
        for unit in recoverableDefenderUnits:
            try:
                remainingDefensePoints += eval(unit + '.points')
            except NameError:
               pass

        query = 'INSERT INTO Games ' \
                '(gameID, victoryTypeID, turns, cpDestroyed, ogreDestroyed, ' + \
                'remainingDefensePoints, timestamp) values ("' + str(gameID) + '", ' + \
                str(typeOfVictory) + ', ' + str(turn) + ', ' + cpDestroyed + ', ' + \
                ogreDestroyed + ', ' + str(remainingDefensePoints) + ', now())'

        cursor.execute(query)
        dbConnection.commit()  # Commit necessary to get 'Game.id'

        # Units are logged before the game, and thus lack a 'gameID',
        # Use the 'gameID' to look up the 'Game.id' (which is much smaller)
        # and update units with a NULL 'gameID' (foreign key) with the
        # newly created 'Game.id'
        query = 'SELECT id from Games WHERE gameID = "' + str(gameID) + '"'
        cursor.execute(query)
        for (id) in cursor:
            gid = id[0]  # Should always only return 1 col and 1 row
        query = 'UPDATE Units SET gameID = ' + str(gid) + ' WHERE gameID IS NULL'
        cursor.execute(query)

        # Log the OGRE status (Useful data for breaking ties if game statistics alone
        # do not differentiate unit selection.)
        query = 'insert into Ogres (gameID, remainingMissiles, ' + \
                'remainingMainBattery, remainingSecondaryBatteries, ' + \
                'remainingAP, remainingTread) values (' + \
                str(gid) + ', ' + str(mk3.missiles) + ', ' + \
                str(mk3.mainBattery) + ', ' + str(mk3.secondaryBattery) + ', ' + \
                str(mk3.antipersonnel) + ', ' + str(mk3.tread) + ')'
        cursor.execute(query)

        # After all inserts
        dbConnection.commit() 
        cursor.close()

        #if DEBUG: 
        print('\nFinal map:', myMap)
        #if DEBUG: 
        print('Game over!')
        #if DEBUG: 
        print('  ', typesOfVictory[typeOfVictory], 'in', turn, 'turns')
        #if DEBUG: 
        print('   OGRE status:')
        print(mk3)

        iterations -= 1
    # // end 'while n' loop
